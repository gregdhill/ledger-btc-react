{"version":3,"sources":["bitcoin.ts","components/SelectAddresses.tsx","components/SelectOutputs.tsx","components/SignAndSend.tsx","App.tsx","serviceWorker.ts","index.tsx","ledger.ts"],"names":["BitcoinApi","txApi","addrApi","blockApi","basePath","this","esplora","txid","getTxHex","data","addr","getAddress","info","chain_stats","funded_txo_sum","getAddressUtxo","map","utxo","value","vout","key","satToBtc","sat","Math","pow","SelectAddresses","state","loaded","accIndex","accounts","Map","index","props","size","setState","loadAccounts","cb","get","checked","set","updateAccount","length","promises","i","ledger","appBtc","push","apiBtc","getAccountValue","then","Promise","all","e","target","removeAccountOutputs","Jumbotron","className","Row","Col","Table","striped","bordered","hover","acc","type","onChange","bind","text","style","cursor","Button","onClick","Component","SelectOutputs","outputs","total","filter","getAccountUtxos","utxos","flat","addOutput","removeOutput","Form","Group","has","substr","toString","SignAndSend","recipient","satoshis","txFee","loading","forEach","error","undefined","txHex","a","getHexTransaction","hex","createTransaction","event","name","controlId","Label","Control","placeholder","handleChange","readOnly","variant","Alert","message","sleep","ms","resolve","setTimeout","App","currentStep","_next","_prev","app","delete","Container","Spinner","as","animation","role","aria-hidden","previousButton","nextButton","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","console","toBufferLE","num","width","buffer","Buffer","from","padStart","slice","reverse","derivePath","keys","purpose","coinType","account","change","deriveKeySet","TESTNET","connect","getLedgerTransport","transport","AppBtc","getWalletAddress","getWalletPublicKey","format","bitcoinAddress","amount","toAddress","txs","tx","splitTransaction","script","bitcoin","p2wpkh","address","network","testnet","outputScript","serializeTransactionOutputs","version","inputs","BigInt","output","createPaymentTransactionNew","associatedKeysets","outputScriptHex","segwit","additionals","isWebUsbSupported","webUsbTransport","isSupported","platform","os","family","create","u2fTransport"],"mappings":"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","file":"static/js/main.32fd55cc.chunk.js","sourcesContent":["import * as esplora from \"@interlay/esplora-btc-api\";\n\nexport interface UTXO {\n  txid: string;\n  value: number;\n  vout: number;\n  addr: string;\n\n  key(): string;\n}\n\nexport interface AccountInfo {\n  checked: boolean;\n  index: number;\n  value: number;\n}\n\nexport class BitcoinApi {\n  txApi: esplora.TxApi;\n  addrApi: esplora.AddressApi;\n  blockApi: esplora.BlockApi;\n\n  constructor() {\n    const basePath = \"https://blockstream.info/testnet/api\";\n    this.txApi = new esplora.TxApi({ basePath: basePath });\n    this.addrApi = new esplora.AddressApi({ basePath: basePath });\n    this.blockApi = new esplora.BlockApi({ basePath: basePath });\n  }\n\n  async getHexTransaction(txid: string): Promise<string> {\n    return (await this.txApi.getTxHex(txid)).data;\n  }\n\n  // accumulated account balance\n  async getAccountValue(addr: string): Promise<number> {\n    const info = (await this.addrApi.getAddress(addr)).data;\n    return info.chain_stats.funded_txo_sum || 0;\n  }\n\n  // all unspent outputs for an account\n  async getAccountUtxos(addr: string): Promise<Array<UTXO>> {\n    const info = (await this.addrApi.getAddressUtxo(addr)).data;\n    return info.map((utxo) => {\n      return {\n        txid: utxo.txid,\n        value: utxo.value,\n        vout: utxo.vout,\n        addr: addr,\n\n        key: () => {\n          return `${utxo.txid}${utxo.vout}`;\n        },\n      };\n    });\n  }\n}\n\nexport function satToBtc(sat: number) {\n  // TODO: use big int library\n  return sat / Math.pow(10, 8);\n}\n","import React, { Component } from \"react\";\nimport { BitcoinApi, satToBtc, AccountInfo } from \"../bitcoin\";\nimport * as ledger from \"../ledger\";\nimport { Row, Col, Table, Button, Jumbotron } from \"react-bootstrap\";\nimport CopyToClipboard from \"react-copy-to-clipboard\";\nimport { FaClipboard } from \"react-icons/fa\";\n\nconst ENTRIES_PER_PAGE = 3;\n\ninterface Props {\n  appBtc: ledger.AppBtc;\n  apiBtc: BitcoinApi;\n  accounts: Map<string, AccountInfo>;\n  updateAccount(addr: string, cb: (info: AccountInfo) => AccountInfo): void;\n  removeAccountOutputs(addr: string): void;\n}\n\ninterface State {\n  loaded: boolean;\n  accIndex: number;\n  accounts: Map<string, AccountInfo>;\n}\n\nexport default class SelectAddresses extends Component<Props, State> {\n  state: State = {\n    loaded: false,\n    accIndex: 0,\n    accounts: new Map<string, AccountInfo>(),\n  };\n\n  async componentDidMount() {\n    const index = this.props.accounts.size;\n    this.setState({\n      accounts: this.props.accounts,\n      accIndex: index,\n    });\n    if (index === 0) {\n      await this.loadAccounts(ENTRIES_PER_PAGE);\n    } else {\n      this.setState({ loaded: true });\n    }\n  }\n\n  updateAccount(addr: string, cb: (info: AccountInfo) => AccountInfo): void {\n    const { accounts } = this.state;\n    const info = cb(\n      accounts.get(addr) || { checked: false, index: 0, value: 0 }\n    );\n    accounts.set(addr, info);\n    this.setState({ accounts });\n    this.props.updateAccount(addr, () => info);\n  }\n\n  async loadAccounts(length: number) {\n    const index = this.state.accIndex;\n    let promises = [];\n    for (let i = index; i < index + length; i++) {\n      const addr = await ledger.getWalletAddress(this.props.appBtc, i);\n      const accounts = this.state.accounts;\n      const info = { checked: false, index: i, value: 0 };\n      this.updateAccount(addr, () => info);\n\n      promises.push(\n        // address fetching is slow so don't block\n        this.props.apiBtc.getAccountValue(addr).then((value) => {\n          const accounts = this.state.accounts;\n          this.updateAccount(addr, (info) => {\n            info.value = value;\n            return info;\n          });\n\n          this.setState({\n            accounts: accounts,\n          });\n        })\n      );\n\n      this.setState({\n        accounts: accounts,\n      });\n    }\n    await Promise.all(promises);\n    this.setState({\n      loaded: true,\n      accIndex: index + length,\n    });\n  }\n\n  onChange(addr: string, e: React.ChangeEvent<HTMLInputElement>) {\n    const { checked } = e.target;\n    this.updateAccount(addr, (info) => {\n      info.checked = checked;\n      return info;\n    });\n\n    // remove any checked utxos\n    if (!checked) {\n      this.props.removeAccountOutputs(addr);\n    }\n  }\n\n  render() {\n    return (\n      <div>\n        <Jumbotron>\n          <h1 className=\"header\">Select Addresses</h1>\n        </Jumbotron>\n\n        <Row className=\"justify-content-md-center\">\n          <Col>\n            <Table striped bordered hover>\n              <thead>\n                <tr>\n                  <th></th>\n                  <th></th>\n                  <th>Address</th>\n                  <th>Value</th>\n                </tr>\n              </thead>\n              <tbody>\n                {[...this.state.accounts].map((acc) => {\n                  return (\n                    <tr key={acc[0]}>\n                      <td>\n                        <input\n                          type=\"checkbox\"\n                          value={acc[0]}\n                          onChange={this.onChange.bind(this, acc[0])}\n                          checked={acc[1].checked}\n                        />\n                      </td>\n                      <td>\n                        <CopyToClipboard text={acc[0]}>\n                          <FaClipboard style={{ cursor: \"pointer\" }} />\n                        </CopyToClipboard>\n                      </td>\n                      <td>{acc[0]}</td>\n                      <td>{satToBtc(acc[1].value)} BTC</td>\n                    </tr>\n                  );\n                })}\n              </tbody>\n            </Table>\n          </Col>\n        </Row>\n        <Row className=\"justify-content-md-center\">\n          {this.state.loaded && (\n            <Button\n              onClick={() => {\n                this.setState({ loaded: false });\n                this.loadAccounts(ENTRIES_PER_PAGE);\n              }}\n            >\n              Show More\n            </Button>\n          )}\n        </Row>\n      </div>\n    );\n  }\n}\n","import React, { Component } from \"react\";\nimport { BitcoinApi, satToBtc, UTXO, AccountInfo } from \"../bitcoin\";\nimport { Table, Form, Jumbotron } from \"react-bootstrap\";\nimport { FaClipboard } from \"react-icons/fa\";\nimport CopyToClipboard from \"react-copy-to-clipboard\";\n\ninterface Props {\n  apiBtc: BitcoinApi;\n  accounts: Map<string, AccountInfo>;\n  outputs: Map<string, UTXO>;\n  addOutput(utxo: UTXO): void;\n  removeOutput(utxo: UTXO): void;\n}\n\ninterface State {\n  outputs: Array<UTXO>;\n  total: number;\n}\n\n// TODO: poll update utxos\nexport default class SelectOutputs extends Component<Props> {\n  state: State = {\n    outputs: [],\n    total: 0,\n  };\n\n  async componentDidMount() {\n    const { apiBtc, accounts } = this.props;\n    // fetch all account utxos\n    const utxos = await Promise.all(\n      [...accounts]\n        .filter(([, info]) => info.checked)\n        .map(([addr]) => {\n          return apiBtc.getAccountUtxos(addr);\n        })\n    );\n    this.setState({\n      outputs: utxos.flat(),\n    });\n  }\n\n  onChange(utxo: UTXO, e: React.ChangeEvent<HTMLInputElement>) {\n    // TODO: display active total\n    let { total } = this.state;\n    const { checked } = e.target;\n\n    if (checked) {\n      this.props.addOutput(utxo);\n      total += utxo.value;\n    } else {\n      this.props.removeOutput(utxo);\n      total -= utxo.value;\n    }\n\n    this.setState({ total: total });\n  }\n\n  render() {\n    return (\n      <div>\n        <Jumbotron>\n          <h1 className=\"header\">Select Unspent Outputs</h1>\n        </Jumbotron>\n\n        <Form.Group>\n          <Table striped bordered hover>\n            <thead>\n              <tr>\n                <th></th>\n                <th></th>\n                <th>TxID</th>\n                <th>Index</th>\n                <th>Value</th>\n              </tr>\n            </thead>\n            <tbody>\n              {this.state.outputs.map((utxo) => {\n                return (\n                  <tr key={utxo.txid}>\n                    <td>\n                      <input\n                        type=\"checkbox\"\n                        value={utxo.txid + utxo.vout}\n                        onChange={this.onChange.bind(this, utxo)}\n                        checked={this.props.outputs.has(utxo.key())}\n                      />\n                    </td>\n                    <td>\n                      <CopyToClipboard text={utxo.txid}>\n                        <FaClipboard style={{ cursor: \"pointer\" }} />\n                      </CopyToClipboard>\n                    </td>\n                    <td>\n                      {utxo.txid.substr(0, 10)}...\n                      {utxo.txid.substr(utxo.txid.length - 10)}\n                    </td>\n                    <td>{utxo.vout}</td>\n                    <td>{satToBtc(utxo.value).toString()} BTC</td>\n                  </tr>\n                );\n              })}\n            </tbody>\n          </Table>\n        </Form.Group>\n      </div>\n    );\n  }\n}\n","import React, { Component } from \"react\";\nimport { BitcoinApi, satToBtc, UTXO, AccountInfo } from \"../bitcoin\";\nimport * as ledger from \"../ledger\";\nimport { Button, Form, Jumbotron, Alert } from \"react-bootstrap\";\n\ntype FormControlElement =\n  | HTMLInputElement\n  | HTMLSelectElement\n  | HTMLTextAreaElement;\n\ninterface Props {\n  appBtc: ledger.AppBtc;\n  apiBtc: BitcoinApi;\n  accounts: Map<string, AccountInfo>;\n  outputs: Map<string, UTXO>;\n}\n\ninterface State {\n  // TODO: allow multiple outputs\n  recipient: string;\n  satoshis: number;\n  txFee: number;\n  loading: boolean;\n  txHex?: string;\n  error?: Error;\n}\n\nexport default class SignAndSend extends Component<Props> {\n  state: State = {\n    recipient: \"\",\n    satoshis: 0,\n    txFee: 0,\n    loading: false,\n  };\n\n  componentDidMount() {\n    let total = 0;\n    this.props.outputs.forEach((utxo) => (total += utxo.value));\n    this.setState({ satoshis: total });\n  }\n\n  async createTransaction() {\n    // clear error and previous raw tx\n    this.setState({ error: undefined, txHex: undefined });\n    const { recipient, satoshis, txFee } = this.state;\n    try {\n      const { appBtc, apiBtc, accounts, outputs } = this.props;\n      let txHex = await ledger.createTransaction(\n        appBtc,\n        // fee is leftover\n        satoshis - txFee,\n        await Promise.all(\n          [...outputs].map(async ([, utxo]) => {\n            return {\n              hex: await apiBtc.getHexTransaction(utxo.txid),\n              index: accounts.get(utxo.addr)!.index,\n              ...utxo,\n            };\n          })\n        ),\n        recipient\n      );\n      // TODO: automatically publish?\n      this.setState({\n        txHex: txHex,\n      });\n    } catch (error) {\n      this.setState({ error: error });\n    }\n  }\n\n  handleChange(event: React.ChangeEvent<FormControlElement>) {\n    let { name, value } = event.target;\n    this.setState({\n      [name]: value,\n    });\n  }\n\n  render() {\n    const { satoshis } = this.state;\n    return (\n      <div>\n        <Jumbotron>\n          <h1 className=\"header\">Confirm & Sign</h1>\n          <p>Enter the recipient and transaction fee before signing.</p>\n        </Jumbotron>\n        <Form>\n          <Form.Group controlId=\"toAddress\">\n            <Form.Label>Recipient</Form.Label>\n            <Form.Control\n              type=\"text\"\n              placeholder=\"Address\"\n              name=\"recipient\"\n              onChange={this.handleChange.bind(this)}\n            />\n          </Form.Group>\n\n          <Form.Group controlId=\"toAmount\">\n            <Form.Label>Amount</Form.Label>\n            <Form.Control\n              type=\"number\"\n              placeholder={satToBtc(satoshis).toString()}\n              readOnly\n            />\n          </Form.Group>\n\n          <Form.Group controlId=\"txFee\">\n            <Form.Label>Transaction Fee</Form.Label>\n            <Form.Control\n              type=\"number\"\n              placeholder=\"Fee\"\n              name=\"txFee\"\n              onChange={this.handleChange.bind(this)}\n            />\n          </Form.Group>\n\n          <Form.Group>\n            <Button\n              variant=\"primary\"\n              type=\"button\"\n              onClick={() => this.createTransaction()}\n            >\n              Sign\n            </Button>\n          </Form.Group>\n\n          {this.state.txHex && (\n            <Form.Group controlId=\"toHex\">\n              <Form.Label>Raw Tx</Form.Label>\n              <Form.Control type=\"text\" value={this.state.txHex} readOnly />\n            </Form.Group>\n          )}\n\n          {this.state.error && (\n            <Form.Group>\n              <Alert key=\"ledgerErr\" variant=\"danger\">\n                {this.state.error.message}\n              </Alert>\n            </Form.Group>\n          )}\n        </Form>\n      </div>\n    );\n  }\n}\n","import React, { Component } from \"react\";\nimport { BitcoinApi, UTXO, AccountInfo } from \"./bitcoin\";\nimport * as ledger from \"./ledger\";\nimport { Container, Jumbotron, Spinner, Button } from \"react-bootstrap\";\nimport \"./App.css\";\nimport SelectAddresses from \"./components/SelectAddresses\";\nimport SelectOutputs from \"./components/SelectOutputs\";\nimport SignAndSend from \"./components/SignAndSend\";\n\ninterface Props {}\n\ninterface State {\n  appBtc?: ledger.AppBtc;\n  apiBtc: BitcoinApi;\n  accounts: Map<string, AccountInfo>;\n  outputs: Map<string, UTXO>;\n  currentStep: number;\n}\n\nfunction sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(() => resolve(), ms));\n}\n\nexport default class App extends Component<Props, State> {\n  state: State = {\n    apiBtc: new BitcoinApi(),\n    accounts: new Map<string, AccountInfo>(),\n    outputs: new Map<string, UTXO>(),\n    currentStep: 1,\n  };\n\n  constructor(props: Props) {\n    super(props);\n    // TODO: hide buttons pending form validation\n    this._next = this._next.bind(this);\n    this._prev = this._prev.bind(this);\n  }\n\n  async componentDidMount() {\n    while (true) {\n      try {\n        // ensures that the device is connected\n        // and working, user may need to exit\n        // and re-enter app if device falls asleep\n        const app = await ledger.connect();\n        await ledger.getWalletAddress(app, 0);\n        this.setState({ appBtc: app });\n        break;\n      } catch (error) {\n        // console.log(error);\n      }\n      await sleep(1000);\n    }\n  }\n\n  _next() {\n    let currentStep = this.state.currentStep;\n    currentStep = currentStep >= 3 ? 3 : currentStep + 1;\n    this.setState({\n      currentStep: currentStep,\n    });\n  }\n\n  _prev() {\n    let currentStep = this.state.currentStep;\n    currentStep = currentStep <= 0 ? 0 : currentStep - 1;\n    this.setState({\n      currentStep: currentStep,\n    });\n  }\n\n  get previousButton() {\n    let currentStep = this.state.currentStep;\n    if (currentStep > 1) {\n      return (\n        <Button\n          variant=\"secondary\"\n          className=\"float-left\"\n          type=\"button\"\n          onClick={this._prev}\n        >\n          Previous\n        </Button>\n      );\n    }\n    return null;\n  }\n\n  get nextButton() {\n    let { currentStep } = this.state;\n\n    if (currentStep < 3) {\n      return (\n        <Button\n          variant=\"primary\"\n          className=\"float-right\"\n          type=\"button\"\n          onClick={this._next}\n        >\n          Next\n        </Button>\n      );\n    }\n    return null;\n  }\n\n  updateAccount(addr: string, cb: (info: AccountInfo) => AccountInfo): void {\n    const { accounts } = this.state;\n    accounts.set(\n      addr,\n      cb(accounts.get(addr) || { checked: false, index: 0, value: 0 })\n    );\n    this.setState({ accounts });\n  }\n\n  removeAccountOutputs(addr: string) {\n    const { outputs } = this.state;\n    outputs.forEach((utxo) => {\n      if (addr === utxo.addr) {\n        outputs.delete(utxo.key());\n      }\n    });\n    this.setState({ outputs });\n  }\n\n  addOutput(utxo: UTXO): void {\n    const { outputs } = this.state;\n    outputs.set(utxo.key(), utxo);\n    this.setState({ outputs });\n  }\n\n  removeOutput(utxo: UTXO): void {\n    const { outputs } = this.state;\n    outputs.delete(utxo.key());\n    this.setState({ outputs });\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        {!this.state.appBtc && (\n          <Container>\n            <Jumbotron>\n              <h1 className=\"header\">Connect Your Device</h1>\n              <p>You may need to open the Bitcoin app.</p>\n            </Jumbotron>\n            <Spinner\n              as=\"span\"\n              animation=\"border\"\n              role=\"status\"\n              aria-hidden=\"true\"\n            />\n          </Container>\n        )}\n        {this.state.appBtc && (\n          <Container>\n            {this.state.currentStep === 1 && (\n              <SelectAddresses\n                updateAccount={this.updateAccount.bind(this)}\n                removeAccountOutputs={this.removeAccountOutputs.bind(this)}\n                appBtc={this.state.appBtc}\n                {...this.state}\n              />\n            )}\n            {this.state.currentStep === 2 && (\n              <SelectOutputs\n                addOutput={this.addOutput.bind(this)}\n                removeOutput={this.removeOutput.bind(this)}\n                appBtc={this.state.appBtc}\n                {...this.state}\n              />\n            )}\n            {this.state.currentStep === 3 && (\n              <SignAndSend appBtc={this.state.appBtc} {...this.state} />\n            )}\n            {this.previousButton}\n            {this.nextButton}\n          </Container>\n        )}\n      </div>\n    );\n  }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nimport \"bootstrap/dist/css/bootstrap.min.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","// YOU MUST ENABLE HTTPS FOR THIS TO WORK\n// HTTPS=true yarn start\n\nimport platform from \"platform\";\nimport u2fTransport from \"@ledgerhq/hw-transport-u2f\";\nimport webUsbTransport from \"@ledgerhq/hw-transport-webusb\";\nimport AppBtc from \"@ledgerhq/hw-app-btc\";\nimport * as bitcoin from \"bitcoinjs-lib\";\nimport { UTXO } from \"./bitcoin\";\n\nexport { AppBtc };\n\nconst OPEN_TIMEOUT = 10000;\nconst LISTENER_TIMEOUT = 300;\n\ntype KeySet = {\n  purpose: number;\n  coinType: number;\n  account: number;\n  change: number;\n};\n\nfunction toBufferLE(num: bigint, width: number) {\n  const hex = num.toString(16);\n  const buffer = Buffer.from(\n    hex.padStart(width * 2, \"0\").slice(0, width * 2),\n    \"hex\"\n  );\n  buffer.reverse();\n  return buffer;\n}\n\nfunction deriveKeySet(keys: KeySet) {\n  return `${keys.purpose}'/${keys.coinType}'/${keys.account}'/${keys.change}`;\n}\n\nfunction derivePath(keys: KeySet, index: number) {\n  return `${deriveKeySet(keys)}/${index}`;\n}\n\n// const MAINNET: KeySet = { purpose: 84, coinType: 0, account: 0, change: 0 };\nconst TESTNET: KeySet = { purpose: 84, coinType: 1, account: 0, change: 0 };\n\nexport async function connect(): Promise<AppBtc> {\n  const transport = await getLedgerTransport();\n  return new AppBtc(transport);\n}\n\nexport async function getWalletAddress(\n  app: AppBtc,\n  index: number\n): Promise<string> {\n  const key = await app.getWalletPublicKey(derivePath(TESTNET, index), {\n    format: \"bech32\",\n  });\n  return key.bitcoinAddress;\n}\n\n// currently only supports segwit\nexport async function createTransaction(\n  app: AppBtc,\n  amount: number,\n  utxos: Array<UTXO & { hex: string; index: number }>,\n  toAddress: string\n): Promise<string> {\n  const txs = utxos.map((utxo) => {\n    return {\n      tx: app.splitTransaction(utxo.hex, true),\n      ...utxo,\n    };\n  });\n\n  const script = bitcoin.payments.p2wpkh({\n    address: toAddress,\n    network: bitcoin.networks.testnet,\n  });\n\n  const outputScript = app\n    .serializeTransactionOutputs({\n      version: Buffer.from(\"01000000\", \"hex\"),\n      inputs: [],\n      outputs: [\n        {\n          amount: toBufferLE(BigInt(amount), 8),\n          script: script.output!,\n        },\n      ],\n    })\n    .toString(\"hex\");\n\n  return app.createPaymentTransactionNew({\n    inputs: txs.map((utxo) => {\n      return [utxo.tx, utxo.vout, null, null];\n    }),\n    associatedKeysets: txs.map((tx) => derivePath(TESTNET, tx.index)),\n    outputScriptHex: outputScript,\n    segwit: true,\n    additionals: [\"bitcoin\", \"bech32\"],\n  });\n}\n\nconst isWebUsbSupported = async (): Promise<boolean> => {\n  // https://github.com/MyEtherWallet/MyEtherWallet/blob/master/src/wallets/hardware/ledger/index.js#L145\n  const isSupported = await webUsbTransport.isSupported();\n  return (\n    isSupported &&\n    platform.os?.family !== \"Windows\" &&\n    platform.name !== \"Opera\"\n  );\n};\n\nconst getLedgerTransport = async () => {\n  const webUsb = await isWebUsbSupported();\n  if (webUsb) {\n    return webUsbTransport.create();\n  } else {\n    return u2fTransport.create(OPEN_TIMEOUT, LISTENER_TIMEOUT);\n  }\n};\n"],"sourceRoot":""}